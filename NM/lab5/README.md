## Практическое задание №4

Выполнил: Веселый Д. А.

Группа: пми-32

Вариант: 7

### **Цель**:

Сформировать практические навыки применения правила Рунге для оценки ошибки численного интегрирования и уточнения по Ричардсону для повышения точности решения прикладных задач.

### **Формулировка задания.**

1. Разработать класс, реализующий любые две схемычисленного интегрирования семейства Ньютона-Котеса и Гаусса с числом узлом интегрирования не
менее двух.
2. Задать на отрезке $[a, b]$ непрерывную  неполиномиальную функцию $\phi(x)$.
3. Вычислить аналитически $I^*=\int_a^b\phi(x)dx$.
4. Для отрезка $[a, b]$ постройте три вложенные сетки с
равномерным шагом $h, h/2 и h/4$. Для каждой из реализованных схем численного интегрирования выполните оценку порядка аппроксимации относительно шага равномерного сеточного разбиения.
5. Для каждой квадратурной формулы заполнить следующую таблицу (все значения приводить в экспоненциальной форме)  

|$h$|$I^*-I^h$|$\frac{I^*-I^h}{I^*-I^{h/2}}$|$\frac{I^{h/2}-I^h}{2^k-1}$|$I^R$|$I^*-I^R$|
|---|---|---|---|---|---|
| | | | | | |
### Исходные данные

|№ варианта|a|b|
|---|---|---|
|7|0.00|0.74|

### Задания 1-5:
Пусть $\phi(x) = \cos(x)$, из варианта $h = b - a = 0.74$.
Была разработана программа, реализующая метод трапеций с теоретическим порядком $k = 2$, и квадратуру Гаусса с 2 узлами $k = 4$. Размер сеток $N = 4, 8, 16$. Аналитическое значение интеграла: $$I^* = \int_a^b \cos(x) \, dx = \sin(b) - \sin(a) = 0.674288$$
### Результат работы программы:
#### Таблица 1: Метод трапеций
|$h$|$I^*-I^h$|$\frac{I^*-I^h}{I^*-I^{h/2}}$|$\frac{I^{h/2}-I^h}{2^k-1}$|$I^R$|$I^*-I^R$|
|---|---|---|---|---|---|
|$1.85*10^{-1}$|$1.92*10^{-3}$|$4.00$|$4.81*10^{-4}$|$6.74*10^{-1}$|$2.75*10^{-7}$|
|$9.25*10^{-2}$|$4.81*10^{-4}$|$4.00$|$1.20*10^{-4}$|$6.74*10^{-1}$|$1.71*10^{-8}$|
#### Вывод: 
Практический порядок сходимости сходится с теоретическим $log_24=2=k$. Экстраполяция Ричардсона значительно повышает точность снижая погрешность в $10^{4}$ раз.
#### Таблица 2: Квадратура Гаусса-2
|$h$|$I^*-I^h$|$\frac{I^*-I^h}{I^*-I^{h/2}}$|$\frac{I^{h/2}-I^h}{2^k-1}$|$I^R$|$I^*-I^R$|
|---|---|---|---|---|---|
|$1.85*10^{-1}$|$1.83*10^{-7}$|$16.0$|$1.14*10^{-8}$|$6.74*10^{-1}$|$9.94*10^{-12}$|
|$9.25*10^{-2}$|$1.14*10^{-8}$|$16.00$|$7.14*10^{-10}$|$6.74*10^{-1}$|$1.55*10^{-13}$|
#### Вывод: 
Практический порядок сходимости сходится с теоретическим $log_216=4=k$. Экстраполяция Ричардсона значительно повышает точность снижая погрешность в $10^{5}$ раз.
### Задание 6: Использование DeepSeek для решения предыдущей задачи
*Промт*: Оптимальный метод численного интегрирования Int{cos(x)}dx x in [0,0.74] с максимальной точностью?
#### Ответ DeepSeek:
Для вычисления интеграла $ \int_{0}^{0.74} \cos(x) \, dx $ с максимальной точностью нужно выбрать метод, который обеспечивает высокую точность при минимальном количестве вычислений подынтегральной функции.

#### Аналитическое решение (для сравнения)
$$\int_{0}^{0.74} \cos(x) \, dx = \sin(x)\Big|_{0}^{0.74} = \sin(0.74) \approx 0.675463
$$

#### Рекомендуемый метод: **Квадратурные формулы Гаусса**

Для достижения максимальной точности при минимальном количестве узлов лучше всего использовать **квадратуру Гаусса**.

#### Почему Гауссова квадратура оптимальна:
- Для полиномов степени $2n-1$ дает точный результат при $n$ узлах
- Обеспечивает экспоненциальную сходимость для аналитических функций
- $\cos(x)$ - аналитическая функция на $[0, 0.74]$

#### Рекомендуемые варианты:

1. **Гауссова квадратура 5-го порядка** (3 узла):
   - Точность: $O(h^{10})$
   - Достаточно для большинства практических задач

2. **Гауссова квадратура 7-го порядка** (4 узла):
   - Точность: $O(h^{14})$
   - Максимальная точность для данного интервала

#### Сравнение методов:

| Метод | Количество узлов | Ожидаемая погрешность |
|-------|------------------|----------------------|
| Правило Симпсона | 3+ | ~10⁻⁵ |
| Гаусс 3 точки | 3 | ~10⁻⁷ |
| Гаусс 4 точки | 4 | ~10⁻¹⁰ |
| Гаусс 5 точек | 5 | ~10⁻¹³ |

#### Практическая реализация (Гаусс 4 точки):

Узлы и веса для $[0, 0.74]$:
$$\begin{aligned}
x_1 &= 0.0370, & w_1 &= 0.173927\\
x_2 &= 0.3320, & w_2 &= 0.326073\\
x_3 &= 0.4080, & w_3 &= 0.326073\\
x_4 &= 0.7030, & w_4 &= 0.173927\\
\end{aligned}$$

Интеграл:
$$I \approx \sum_{i=1}^{4} w_i \cdot \cos(x_i)$$

#### Вывод

**Оптимальный метод**: **Квадратура Гаусса с 4 узлами** обеспечивает точность порядка $10^{-10}$ при минимальных вычислительных затратах.

Для большинства практических применений достаточно 3 узлов (точность ~$10^{-7}$), но если требуется максимальная точность - используйте 4-5 узлов.
### Задание 3: Анализ ответа DeepSeek:
Сперва модель посчитала аналитическое значение интеграла, при этом ошибочно с **большой погрешностью**. Затем предложила использовать квадратуры Гаусса так как они дают **максимальную** точность. Сравнение с другими методами (Симпсона) нейросеть произвела где-то за кулисами и вывела результат сравнение в виде таблицы. **Вывод** ответ правильный, но обоснований недостаточны, так как сравнение с другими методами не показано явно.

### Вывод
В ходе выполнения работы я сформировал практические навыки применения правила Рунге для оценки ошибки численного интегрирования и уточнения по Ричардсону для повышения точности решения прикладных задач.

### Приложение
#### Код программы (C++): main.cc
```cpp
#include <cmath>
#include <functional>
#include <iomanip>
#include <iostream>

using ld = long double;
using namespace std;

class Quadrature {
 public:
  Quadrature(function<ld(ld)> func, ld a, ld b) : f(func), a(a), b(b) {}

  ld integrateTrapezoidal(int n) const {
    if (n < 1) n = 1;
    ld h = (b - a) / n;
    ld sum = 0.5 * (f(a) + f(b));
    for (int i = 1; i < n; ++i) {
      ld x = a + i * h;
      sum += f(x);
    }
    return sum * h;
  }

  ld integrateGauss2(int m) const {
    if (m < 1) m = 1;
    ld xi1 = -1.0 / sqrt(3.0);
    ld xi2 = 1.0 / sqrt(3.0);
    ld w1 = 1.0;
    ld w2 = 1.0;
    ld h = (b - a) / m;
    ld total = 0.0;
    for (int j = 0; j < m; ++j) {
      ld x0 = a + j * h;
      ld x1 = a + (j + 1) * h;
      ld mid = 0.5 * (x0 + x1);
      ld half = 0.5 * (x1 - x0);
      ld s = 0.0;
      ld x_loc1 = mid + half * xi1;
      ld x_loc2 = mid + half * xi2;
      s += w1 * f(x_loc1);
      s += w2 * f(x_loc2);

      total += half * s;
    }
    return total;
  }

  ld getH(int n = 1) const { return (n != 0) ? (b - a) / n : -1; }

  double richardson(double I_h, double I_h2, int p) const {
    return I_h2 + (I_h2 - I_h) / (std::pow(2.0, p) - 1.0);
  }

 private:
  function<ld(ld)> f;
  ld a, b;
};

int main() {
  auto func = [](ld x) { return cos(x); };
  ld a = 0.00, b = 0.74;

  Quadrature Q(func, a, b);

  int n = 4;
  ld exact = sin(b) - sin(a);
  cout << "Интеграл f(x)=e^x на [" << a << ", " << b << "]\n";
  cout << "Точное значение   : " << exact << "\n";
  cout << scientific << setprecision(5);
  cout << "Метод трапеций\n";
  for (int i = 0; i < 2; ++i) {
    int _n = n * pow(2, i);
    cout << "Шаг h = " << Q.getH(_n) << "\n";
    ld trap = Q.integrateTrapezoidal(_n);
    cout << "Трапеции (n=" << _n << "): " << trap
         << "  | ошибка = " << fabs(trap - exact) << "\n";
    ld trap2 = Q.integrateTrapezoidal(_n * 2);
    cout << "Ошибка2: " << fabs(trap - exact) / fabs(trap2 - exact) << "\n";
    cout << "Ошибка3: " << (trap2 - trap) / (pow(2, 2) - 1) << "\n";
    ld r = Q.richardson(trap, trap2, 2);
    cout << "Ричардсон: " << r << "\n";
    cout << "Ошибка Ричардсон: " << fabs(r - exact) << "\n";
  }
  cout << "Метод квадратуры Гаусса\n";
  for (int i = 0; i < 2; ++i) {
    int _n = n * pow(2, i);
    cout << "Шаг h = " << Q.getH(_n) << "\n";
    ld g = Q.integrateGauss2(_n);
    cout << "Гаусс2 (n=" << _n << "): " << g
         << "  | ошибка = " << fabs(g - exact) << "\n";
    ld g2 = Q.integrateGauss2(_n * 2);
    cout << "Ошибка2: " << fabs(g - exact) / fabs(g2 - exact) << "\n";
    cout << "Ошибка3: " << (g2 - g) / (pow(2, 4) - 1) << "\n";
    ld r = Q.richardson(g, g2, 4);
    cout << "Ричардсон: " << r << "\n";
    cout << "Ошибка Ричардсон: " << fabs(r - exact) << "\n";
  }
  return 0;
}
```
